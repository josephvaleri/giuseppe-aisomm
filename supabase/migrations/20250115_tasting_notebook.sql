-- Tasting Notebook Feature Migration
-- Creates tables for wine tasting notes with comprehensive tracking

-- Table: tasting_notes
create table if not exists public.tasting_notes (
  note_id            bigint generated by default as identity primary key,
  user_id            uuid not null references public.profiles(user_id) on delete cascade,
  created_at         timestamptz not null default now(),
  updated_at         timestamptz not null default now(),

  -- Core wine fields (editable)
  tasting_date       date not null default (current_date),
  wine_name          text,
  producer           text,
  grapes             text, -- free text or comma list
  vintage            text,
  alcohol_pct        text,
  country_id         text,     -- FK to countries_regions.country_id (string codes like 'USA', 'ITA')
  region_id          integer,  -- FK to countries_regions.region_id if you have it (nullable)
  price              numeric(10,2),
  my_notes           text,
  drink_starting     text,
  drink_by           text,
  bottle_size        text,
  is_bubbly          boolean default false,

  -- Appearance
  appearance_color   text,     -- name from color guide list

  -- Aroma (stored as array of enums/labels for simplicity; separate join also provided)
  aroma_tags         text[],

  -- Palate sliders (1–10)
  sweetness          int2 check (sweetness between 1 and 10),
  acidity            int2 check (acidity between 1 and 10),
  body               int2 check (body between 1 and 10),
  tannin             int2 check (tannin between 1 and 10),
  oak                int2 check (oak between 1 and 10),
  old_world_bias     int2 check (old_world_bias between 1 and 10),
  finish_len         int2 check (finish_len between 1 and 10),

  -- 5-bottle rating (1–5; allow half steps via numeric)
  rating_bottles     numeric(2,1) check (rating_bottles >= 0 and rating_bottles <= 5)
);

-- Optional lookup for standardized aroma terms
create table if not exists public.aroma_terms (
  aroma_id bigint generated by default as identity primary key,
  label    text unique not null
);

-- Optional join if you prefer normalized aroma storage alongside array
create table if not exists public.tasting_note_aromas (
  note_id  bigint not null references public.tasting_notes(note_id) on delete cascade,
  aroma_id bigint not null references public.aroma_terms(aroma_id) on delete cascade,
  primary key (note_id, aroma_id)
);

-- Helpful indexes
create index if not exists idx_tasting_notes_user_date on public.tasting_notes(user_id, tasting_date desc);
create index if not exists idx_tasting_notes_textsearch on public.tasting_notes using gin (to_tsvector('simple', coalesce(wine_name,'') || ' ' || coalesce(producer,'') || ' ' || coalesce(my_notes,'')));

-- Updated at trigger
create or replace function public.set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at := now();
  return new;
end; $$;

drop trigger if exists trg_tasting_notes_updated_at on public.tasting_notes;
create trigger trg_tasting_notes_updated_at
before update on public.tasting_notes
for each row execute function public.set_updated_at();

-- RLS Policies
alter table public.tasting_notes enable row level security;
alter table public.aroma_terms enable row level security;
alter table public.tasting_note_aromas enable row level security;

-- Only owners can CRUD their notes
create policy "tasting_notes_select_own" on public.tasting_notes
  for select using (auth.uid() = user_id);

create policy "tasting_notes_insert_own" on public.tasting_notes
  for insert with check (auth.uid() = user_id);

create policy "tasting_notes_update_own" on public.tasting_notes
  for update using (auth.uid() = user_id);

create policy "tasting_notes_delete_own" on public.tasting_notes
  for delete using (auth.uid() = user_id);

-- Aroma terms: read-only public, insert/update restricted to role 'service_role' (server)
create policy "aroma_terms_read_all" on public.aroma_terms
  for select using (true);

-- Join table mirrors note owner
create policy "tna_select_own" on public.tasting_note_aromas
  for select using (exists (select 1 from public.tasting_notes n where n.note_id = note_id and n.user_id = auth.uid()));

create policy "tna_insert_own" on public.tasting_note_aromas
  for insert with check (exists (select 1 from public.tasting_notes n where n.note_id = note_id and n.user_id = auth.uid()));

create policy "tna_delete_own" on public.tasting_note_aromas
  for delete using (exists (select 1 from public.tasting_notes n where n.note_id = note_id and n.user_id = auth.uid()));

-- Seed aroma terms (30+ broadly useful terms)
insert into public.aroma_terms(label) values
('Citrus'),('Green Apple'),('Stone Fruit'),('Tropical'),('Red Berry'),('Blackberry'),
('Blackcurrant'),('Cherry'),('Plum'),('Dried Fruit'),('Floral'),('Violet'),('Rose'),
('Herbal'),('Mint'),('Eucalyptus'),('Vegetal'),('Bell Pepper'),('Savory'),('Meaty'),
('Spice'),('Black Pepper'),('Clove'),('Cinnamon'),('Vanilla'),('Oak'),('Smoke'),
('Toast'),('Coffee'),('Chocolate'),('Cocoa'),('Nutty'),('Honey'),('Mineral'),
('Saline'),('Petrol'),('Earth'),('Mushroom'),('Leather'),('Tobacco')
on conflict do nothing;
